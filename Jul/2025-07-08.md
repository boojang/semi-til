# ☀️SEMI TIL


- **날짜: 2025-07-08**

- 🗣️**스크럼**
  - 학습 목표 1 : 포트폴리오 수정

  - 학습 목표 2 :  CS 공부하기

  - 학습 목표 3 : 코테 풀기

<br>

## ❤️‍🔥새로 배운 내용

### 1️⃣ HTTP/1.0

- 요청을 하나 보낼 때마다 **새로운 TCP 연결**을 만들어야 한다.

- 매 요청마다 연결을 새로 열고 닫기 때문에 **오버헤드**가 크고, 속도가 느리다.


### 2️⃣ HTTP/1.1

- **지속 연결**(Persistent Connection) 지원
  - 한 번 연결을 열면 여러 요청을 이어서 처리할 수 있다.


- **파이프라이닝**(Pipelining) 지원
  - 여러 개의 요청을 연속적으로 보내고, 응답은 순서대로 받는다.

  <br>
  
  ```plain text
  클라이언트: 요청1 → 요청2 → 요청3  (빠르게 연속적으로 보냄)
  서버: 응답1 → 응답2 → 응답3 (순서 지켜서 반환
  ```


- **🚨 파이프라이닝의 문제점**
  - 첫 번째 요청이 느리면, 뒤에 있는 요청들도 **같이 기다려야 한다**.

  - 매번 **같은 헤더**를 반복적으로 전송 → 데이터 낭비


### 3️⃣ HTTP/2.0

- 데이터를 **텍스트가 아닌 바이너리** 형태로 전송 → 더 빠르고 효율적

- **프레임**(Frame) 단위로 데이터를 잘게 나눠 전송

- **멀티플렉싱**(Multiplexing) 지원
  - 하나의 연결에서 여러 요청과 응답을 **동시에, 독립적으로** 처리 가능

  - 첫 번째 요청이 느려도 다른 요청을 동시에 처리 → HOL 문제 해결

  ```plain text
  클라이언트: 요청1 ─┐
                     ├→ 동시에 전송 → 서버
  클라이언트: 요청2 ─┘
  
  서버: 응답2 → 먼저 준비된 응답 반환
  서버: 응답1 → 나중에 준비된 응답 반환
  ```


### 💡 멀티플렉싱 정리

### ✅ 요청/응답 구분 방식

- 하나의 TCP 연결 안에서 **Stream ID**로 요청과 응답을 구분

- HTTP/2.0은 메시지를 **프레임(Frame)** 단위로 쪼개고, 각 프레임에 **Stream ID**를 포함

예시:

- 요청1 → Stream ID: 1

- 요청2 → Stream ID: 3

- 요청3 → Stream ID: 5

- 서버는 응답 프레임에 Stream ID를 포함해 클라이언트가 맞춰서 조립

### ⚠️ 멀티플렉싱의 단점

1. **TCP 레벨에서 HOL Blocking 문제는 여전히 존재**
  - 하나의 TCP 연결에서 패킷 손실이 생기면, 전체 데이터가 재전송을 기다려야 함

  - TCP는 **순서 보장**을 위해 수신 측에서 순서를 재조립함


2. **서버/클라이언트 구현 복잡도 증가**
  - Stream 관리, 프레임 처리, 헤더 압축 등 처리 로직 복잡


### 4️⃣ TCP 주요 특징

| 특징 | 설명 |
| --- | --- |
| 연결 지향적 | **3-way handshake**로 연결 수립 후 통신 |
| 신뢰성 보장 | 손실된 데이터는 재전송, 오류 체크 |
| 순서 보장 | 순서 번호 기반으로 데이터 재조립 |
| 흐름 제어 | 수신 측 속도에 맞춰 데이터 전송 |
| 혼잡 제어 | 네트워크 혼잡 시 전송 속도 조절 |


<br>


## ✏️오늘의 결과물

- 고대하던 포트폴리오를 수정했습니다.. 하지만 고쳐도 고쳐도 부족한 느낌..
  
<br>

## 🤔오늘의 회고

- **Keep(만족했던 부분)**: 하기 싫은 감정을 무시하고 결과를 만들려고 했다.

- **Problem(개선이 필요한 부분):** 성장이 더딘 느낌이다. 시간을 효율적으로 사용하지 못하고 있다.

- **Try(지금 할 수 있는 행동)**: 멀티 태스킹을 지양하자.

<br>

## 🙏참고 자료 및 링크

[HTTP3까지 버전별 변천사](https://velog.io/@yesbb/HTTP3까지-버전별-변천사#2-tcp레벨에서의-holbhead-of-line-blocking-)

